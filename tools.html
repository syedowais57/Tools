<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Polygon Bounding Box Generator</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 15px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    .header {
      background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
      color: white;
      text-align: center;
      padding: 30px;
    }

    .header h1 {
      font-size: 2.5em;
      margin-bottom: 10px;
    }

    .header p {
      font-size: 1.1em;
      opacity: 0.9;
    }

    .content {
      padding: 40px;
    }

    .input-section {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 30px;
      margin-bottom: 30px;
    }

    .input-group {
      background: #f8f9fa;
      padding: 25px;
      border-radius: 10px;
      border: 2px dashed #dee2e6;
      transition: all 0.3s ease;
    }

    .input-group:hover {
      border-color: #4facfe;
      transform: translateY(-2px);
    }

    .input-group label {
      display: block;
      font-weight: 600;
      margin-bottom: 10px;
      color: #495057;
      font-size: 1.1em;
    }

    .file-input {
      width: 100%;
      padding: 12px;
      border: 2px solid #dee2e6;
      border-radius: 8px;
      font-size: 16px;
      transition: border-color 0.3s ease;
    }

    .file-input:focus {
      outline: none;
      border-color: #4facfe;
    }

    .coordinate-input-container {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }

    .coordinate-input {
      flex: 2;
      padding: 12px;
      border: 2px solid #dee2e6;
      border-radius: 8px;
      font-size: 16px;
      transition: border-color 0.3s ease;
    }

    .coordinate-input:focus {
      outline: none;
      border-color: #4facfe;
    }

    .label-input {
      flex: 1;
      padding: 12px;
      border: 2px solid #dee2e6;
      border-radius: 8px;
      font-size: 16px;
      transition: border-color 0.3s ease;
    }

    .label-input:focus {
      outline: none;
      border-color: #4facfe;
    }

    .add-box-btn {
      background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
      color: white;
      border: none;
      padding: 12px 20px;
      font-size: 14px;
      font-weight: 600;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      white-space: nowrap;
    }

    .add-box-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 5px 15px rgba(79, 172, 254, 0.3);
    }

    .add-box-btn:disabled {
      background: #6c757d;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .polygon-textarea {
      width: 100%;
      min-height: 120px;
      padding: 12px;
      border: 2px solid #dee2e6;
      border-radius: 8px;
      font-size: 14px;
      font-family: "Courier New", monospace;
      resize: vertical;
      transition: border-color 0.3s ease;
      margin-bottom: 10px;
    }

    .polygon-textarea:focus {
      outline: none;
      border-color: #4facfe;
    }

    .bounding-box-list {
      margin-top: 15px;
      background: white;
      border-radius: 8px;
      max-height: 200px;
      overflow-y: auto;
      display: none;
    }

    .bounding-box-list.has-boxes {
      display: block;
      border: 1px solid #dee2e6;
    }

    .list-header {
      font-weight: 600;
      color: #495057;
      padding: 10px 15px;
      border-bottom: 1px solid #dee2e6;
      background: #f8f9fa;
      font-size: 0.9em;
    }

    .box-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 15px;
      border-bottom: 1px solid #f1f3f4;
      transition: background-color 0.2s ease;
    }

    .box-item:hover {
      background-color: #f8f9fa;
    }

    .box-item:last-child {
      border-bottom: none;
    }

    .box-info {
      flex: 1;
    }

    .box-coordinates {
      font-family: "Courier New", monospace;
      font-size: 0.9em;
      color: #495057;
      font-weight: 500;
    }

    .box-label {
      font-size: 0.8em;
      color: #6c757d;
      margin-top: 2px;
    }

    .box-color {
      width: 20px;
      height: 20px;
      border-radius: 4px;
      margin-right: 10px;
      border: 2px solid white;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
    }

    .box-actions {
      display: flex;
      gap: 5px;
    }

    .remove-box-btn {
      background: #dc3545;
      color: white;
      border: none;
      padding: 6px 10px;
      font-size: 12px;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }

    .remove-box-btn:hover {
      background: #c82333;
    }

    .bulk-import-section {
      margin-top: 20px;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 10px;
      border: 2px dashed #dee2e6;
      transition: all 0.3s ease;
    }

    .bulk-import-section:hover {
      border-color: #4facfe;
      transform: translateY(-1px);
    }

    .bulk-import-section label {
      display: block;
      font-weight: 600;
      margin-bottom: 10px;
      color: #495057;
      font-size: 1.1em;
    }

    .bulk-textarea {
      width: 100%;
      min-height: 120px;
      padding: 12px;
      border: 2px solid #dee2e6;
      border-radius: 8px;
      font-size: 14px;
      font-family: "Courier New", monospace;
      resize: vertical;
      transition: border-color 0.3s ease;
      margin-bottom: 10px;
    }

    .bulk-textarea:focus {
      outline: none;
      border-color: #4facfe;
    }

    .import-btn {
      background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
      color: white;
      border: none;
      padding: 12px 24px;
      font-size: 14px;
      font-weight: 600;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      width: 100%;
    }

    .import-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 5px 15px rgba(40, 167, 69, 0.3);
    }

    .import-btn:disabled {
      background: #6c757d;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .clear-all-btn {
      background: linear-gradient(135deg, #dc3545 0%, #e74c3c 100%);
      color: white;
      border: none;
      padding: 8px 16px;
      font-size: 12px;
      font-weight: 600;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.3s ease;
      margin-left: 10px;
    }

    .clear-all-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 3px 10px rgba(220, 53, 69, 0.3);
    }

    /* Commented out sections */
    .commented-section {
      display: none;
    }

    .help-text {
      font-size: 0.9em;
      color: #6c757d;
      margin-top: 8px;
    }

    .generate-btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 15px 30px;
      font-size: 1.1em;
      font-weight: 600;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: block;
      margin: 20px auto;
    }

    .generate-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
    }

    .generate-btn:disabled {
      background: #6c757d;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .result-section {
      margin-top: 30px;
      text-align: center;
    }

    .image-container {
      position: relative;
      display: inline-block;
      margin: 20px auto;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }

    .uploaded-image {
      max-width: 100%;
      max-height: 600px;
      display: block;
    }

    .bounding-box {
      position: absolute;
      border: 2px solid #ff4757;
      background: rgba(255, 71, 87, 0.1);
      box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.8);
    }

    .polygon-overlay {
      position: absolute;
      pointer-events: none;
    }

    .coordinates-display {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 8px;
      margin-top: 15px;
      border-left: 4px solid #4facfe;
    }

    .error-message {
      background: #ffe6e6;
      color: #d63031;
      padding: 15px;
      border-radius: 8px;
      margin: 15px 0;
      border-left: 4px solid #d63031;
    }

    /* Tool Tabs */
    .tool-tabs {
      display: flex;
      margin-bottom: 30px;
      border-bottom: 2px solid #dee2e6;
      gap: 5px;
      flex-wrap: wrap;
    }

    .tab-btn {
      background: none;
      border: none;
      padding: 15px 25px;
      font-size: 1.1em;
      font-weight: 600;
      color: #6c757d;
      cursor: pointer;
      border-radius: 8px 8px 0 0;
      transition: all 0.3s ease;
      position: relative;
    }

    .tab-btn:hover {
      background: #f8f9fa;
      color: #4facfe;
    }

    .tab-btn.active {
      background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
      color: white;
      box-shadow: 0 2px 8px rgba(79, 172, 254, 0.3);
    }

    .tab-btn.active::after {
      content: "";
      position: absolute;
      bottom: -2px;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    }

    /* Tool Sections */
    .tool-section {
      animation: fadeIn 0.3s ease-in;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* PDF Merger Specific Styles */
    .merge-controls {
      text-align: center;
      margin: 30px 0;
    }

    .pdf-status {
      margin: 20px auto;
      max-width: 400px;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 10px;
      border: 2px solid #dee2e6;
    }

    .status-message {
      text-align: center;
      margin-bottom: 15px;
      font-weight: 600;
      color: #495057;
    }

    .progress-bar {
      width: 100%;
      height: 8px;
      background: #dee2e6;
      border-radius: 4px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
      width: 0%;
      transition: width 0.3s ease;
      border-radius: 4px;
    }

    .pdf-result {
      text-align: center;
      margin: 30px 0;
    }

    .pdf-preview {
      background: #f8f9fa;
      border: 2px solid #28a745;
      border-radius: 15px;
      padding: 30px;
      max-width: 500px;
      margin: 0 auto;
      box-shadow: 0 10px 30px rgba(40, 167, 69, 0.1);
    }

    .pdf-preview h3 {
      color: #28a745;
      margin-bottom: 15px;
      font-size: 1.5em;
    }

    .pdf-preview p {
      color: #6c757d;
      margin-bottom: 25px;
      font-size: 1.1em;
    }

    .download-btn {
      background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
      color: white;
      border: none;
      padding: 15px 30px;
      font-size: 1.1em;
      font-weight: 600;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .download-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(40, 167, 69, 0.3);
    }

    .download-btn:disabled {
      background: #6c757d;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    @media (max-width: 768px) {
      .input-section {
        grid-template-columns: 1fr;
        gap: 20px;
      }

      .content {
        padding: 20px;
      }

      .header h1 {
        font-size: 2em;
      }

      .tool-tabs {
        flex-direction: column;
      }

      .tab-btn {
        border-radius: 8px;
        margin-bottom: 5px;
      }

      .tab-btn.active::after {
        display: none;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <h1>üéØ Multi-Tool Generator</h1>
      <p>
        Upload images for polygon bounding boxes or merge PDF files - all in
        one place
      </p>
    </div>

    <div class="content">
      <!-- Tool Tabs -->
      <div class="tool-tabs">
        <button id="boundingBoxTab" class="tab-btn active" onclick="switchTool('boundingBox')">
          üéØ Bounding Box Generator
        </button>
        <button id="pdfMergerTab" class="tab-btn" onclick="switchTool('pdfMerger')">
          üìÑ PDF Merger
        </button>
        <button id="zipMergerTab" class="tab-btn" onclick="switchTool('zipMerger')">
          üóúÔ∏è ZIP ‚Üí Merged PDF
        </button>
        <button id="measurementTab" class="tab-btn" onclick="switchTool('measurement')">
          üìè Measurement Tool
        </button>
        <button id="pdfToPagesTab" class="tab-btn" onclick="switchTool('pdfToPages')">
          üìÑ PDF ‚Üí Pages
        </button>
      </div>

      <!-- Bounding Box Tool -->
      <div id="boundingBoxTool" class="tool-section">
        <div class="input-section">
          <div class="input-group">
            <label for="imageInput">üì∏ Upload Image</label>
            <input type="file" id="imageInput" class="file-input" accept="image/*" />
            <div class="help-text">
              Supported formats: JPG, PNG, GIF, WebP
            </div>
          </div>

          <div class="input-group">
            <label for="polygonCoords">üìê Polygon Coordinates</label>
            <textarea id="polygonCoords" class="polygon-textarea"
              placeholder='Enter polygon coordinates in JSON format:&#10;[&#10;  {"x": 4017.0, "y": 2203.0},&#10;  {"x": 468.0, "y": 2203.0},&#10;  {"x": 468.0, "y": 1132.0},&#10;  {"x": 4017.0, "y": 1132.0}&#10;]&#10;&#10;Or with angle:&#10;{"coords": [{"x": 4017.0, "y": 2203.0}, {"x": 468.0, "y": 2203.0}, {"x": 468.0, "y": 1132.0}, {"x": 4017.0, "y": 1132.0}], "angle": 45}'></textarea>
            <div class="coordinate-input-container">
              <input type="text" id="polygonLabel" class="label-input" placeholder="Label (optional)" />
              <input type="number" id="polygonAngle" class="label-input" placeholder="Angle (0-360¬∞)" min="0" max="360"
                step="0.1" />
              <button id="addPolygonBtn" class="add-box-btn" type="button">
                Add Polygon
              </button>
            </div>
            <div class="help-text">
              Enter polygon coordinates as JSON array with x,y points.
              Optionally specify rotation angle in degrees.
            </div>

            <div class="bulk-import-section">
              <label for="bulkData">üìã Bulk Import Polygon Data</label>
              <textarea id="bulkData" class="bulk-textarea"
                placeholder='Paste multiple polygon data here...&#10;&#10;Format:&#10;Polygon 1: {"coords": [{"x": 100, "y": 100}, {"x": 200, "y": 100}, {"x": 200, "y": 200}, {"x": 100, "y": 200}], "angle": 45}&#10;Polygon 2: {"coords": [{"x": 300, "y": 300}, {"x": 400, "y": 300}, {"x": 400, "y": 400}], "angle": 90}&#10;&#10;Or simple format:&#10;Polygon 1: [{"x": 100, "y": 100}, {"x": 200, "y": 100}, {"x": 200, "y": 200}, {"x": 100, "y": 200}]'></textarea>
              <button id="importBtn" class="import-btn" type="button">
                Import All Polygons
              </button>
            </div>

            <div id="boundingBoxList" class="bounding-box-list">
              <div class="list-header">Added Polygons:</div>
            </div>
          </div>
        </div>

        <!-- Commented out: Pixel Distance Measurement Tool -->
        <div class="measurement-section commented-section">
          <div class="section-header">
            <h2>üìè Pixel Distance Measurement Tool</h2>
            <p>
              Upload an image and click two points to measure the pixel
              distance between them
            </p>
          </div>
        </div>

        <!-- Commented out: Image Comparison Section -->
        <div class="comparison-section commented-section">
          <div class="section-header">
            <h2>üîÑ Image Comparison Tool</h2>
            <p>
              Upload two images and mark bounding boxes on each for comparison
            </p>
          </div>
        </div>

        <button id="generateBtn" class="generate-btn" disabled>
          Generate Visualization
        </button>

        <div id="errorMessage" class="error-message" style="display: none"></div>

        <div class="result-section">
          <div id="imageContainer" class="image-container" style="display: none">
            <img id="uploadedImage" class="uploaded-image" alt="Uploaded image" />
            <div id="boundingBoxContainer"></div>
          </div>

          <div id="coordinatesDisplay" class="coordinates-display" style="display: none">
            <strong>Polygon Information:</strong>
            <div id="coordinatesText"></div>
          </div>
        </div>
      </div>

      <!-- PDF Merger Tool -->
      <div id="pdfMergerTool" class="tool-section" style="display: none">
        <div class="input-section">
          <div class="input-group">
            <label for="pdfFile1">üìÑ First PDF File</label>
            <input type="file" id="pdfFile1" class="file-input" accept=".pdf" />
            <div class="help-text">Select the first PDF to merge</div>
          </div>

          <div class="input-group">
            <label for="pdfFile2">üìÑ Second PDF File</label>
            <input type="file" id="pdfFile2" class="file-input" accept=".pdf" />
            <div class="help-text">Select the second PDF to merge</div>
          </div>
        </div>

        <div class="merge-controls">
          <button id="mergePdfBtn" class="generate-btn" disabled>
            üìÑ Merge PDFs
          </button>

          <div id="pdfStatus" class="pdf-status" style="display: none">
            <div class="status-message"></div>
            <div class="progress-bar">
              <div class="progress-fill"></div>
            </div>
          </div>
        </div>

        <div id="pdfResult" class="pdf-result" style="display: none">
          <div class="pdf-preview">
            <h3>‚úÖ PDF Merge Complete</h3>
            <p>Your merged PDF is ready for download!</p>
            <button id="downloadBtn" class="download-btn">
              üíæ Download Merged PDF
            </button>
          </div>
        </div>
      </div>

      <!-- ZIP ‚Üí Merged PDF Tool -->
      <div id="zipMergerTool" class="tool-section" style="display: none">
        <div class="input-section">
          <div class="input-group">
            <label for="zipInput">üóúÔ∏è Upload ZIP containing PDFs</label>
            <input type="file" id="zipInput" class="file-input" accept=".zip,application/zip" />
            <div class="help-text">
              The ZIP can contain PDFs in nested folders. Non-PDF files will be ignored.
            </div>
          </div>

          <div class="input-group">
            <label>üìã Files detected in ZIP</label>
            <div id="zipPdfList" class="bounding-box-list" style="display:block; min-height: 52px;">
              <div class="list-header">No ZIP loaded yet</div>
            </div>

            <div class="help-text" style="margin-top:10px;">
              Order: path (natural, case-insensitive). You can re-order later in code if you need a custom strategy.
            </div>
          </div>
        </div>

        <div class="merge-controls">
          <button id="mergeZipBtn" class="generate-btn" disabled>
            üóúÔ∏è Merge PDFs from ZIP
          </button>

          <div id="zipStatus" class="pdf-status" style="display: none">
            <div class="status-message"></div>
            <div class="progress-bar">
              <div class="progress-fill"></div>
            </div>
          </div>
        </div>

        <div id="zipResult" class="pdf-result" style="display: none">
          <div class="pdf-preview">
            <h3>‚úÖ ZIP Merge Complete</h3>
            <p>Your merged PDF is ready for download!</p>
            <button id="zipDownloadBtn" class="download-btn">
              üíæ Download Merged PDF
            </button>
          </div>
        </div>
      </div>

      <!-- Measurement Tool -->
      <div id="measurementTool" class="tool-section" style="display: none">
        <div class="input-section">
          <div class="input-group">
            <label for="measureImageInput">üì∏ Upload Image for Measurement</label>
            <input type="file" id="measureImageInput" class="file-input" accept="image/*" />
            <div class="help-text">
              Click two points on the image to measure pixel distance.
            </div>
          </div>

          <div class="input-group" style="
                display: flex;
                flex-direction: column;
                gap: 10px;
                justify-content: center;
              ">
            <button id="measureResetBtn" class="clear-all-btn" type="button" style="align-self: flex-start">
              Reset Measurement
            </button>
            <div id="measureInfo" class="coordinates-display" style="display: none"></div>
          </div>
        </div>

        <div class="result-section">
          <div id="measureContainer" class="image-container" style="display: none">
            <img id="measureImage" class="uploaded-image" alt="Measurement image" />
            <canvas id="measureCanvas" style="position: absolute; top: 0; left: 0"></canvas>
          </div>
        </div>
      </div>
    </div>

    <!-- PDF to Pages Tool -->
    <div id="pdfToPagesTool" class="tool-section" style="display: none">
      <div class="input-section">
        <div class="input-group">
          <label for="pdfToPagesInput">üìÑ Upload PDF</label>
          <input type="file" id="pdfToPagesInput" class="file-input" accept=".pdf" />
          <div class="help-text">Upload a PDF to convert pages to images.</div>
        </div>
        <div class="input-group">
          <button id="downloadAllPagesBtn" class="generate-btn" disabled>
            üì¶ Download All as ZIP
          </button>
        </div>
      </div>
      <div id="pdfToPagesStatus" class="status-container" style="display: none">
        <div class="progress-bar">
          <div class="progress-fill"></div>
        </div>
        <div class="status-message">Processing...</div>
      </div>
      <div id="pdfPagesResults"
        style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px; margin-top: 20px;">
      </div>
    </div>
  </div>
  </div>

  <!-- PDF-lib for PDF manipulation -->
  <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
  <!-- JSZip for reading .zip files in the browser -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <!-- pdf.js for PDF rendering -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
  </script>

  <script>
    // Tool switching functionality
    function switchTool(toolName) {
      // Update tab states
      document
        .querySelectorAll(".tab-btn")
        .forEach((btn) => btn.classList.remove("active"));
      document.getElementById(toolName + "Tab").classList.add("active");

      // Show/hide tool sections
      document.querySelectorAll(".tool-section").forEach((section) => {
        section.style.display = "none";
      });
      document.getElementById(toolName + "Tool").style.display = "block";
    }

    // PDF Merger Class
    class PDFMerger {
      constructor() {
        this.pdfFile1 = document.getElementById("pdfFile1");
        this.pdfFile2 = document.getElementById("pdfFile2");
        this.mergePdfBtn = document.getElementById("mergePdfBtn");
        this.pdfStatus = document.getElementById("pdfStatus");
        this.pdfResult = document.getElementById("pdfResult");
        this.downloadBtn = document.getElementById("downloadBtn");
        this.mergedPdfData = null;

        this.initEventListeners();
      }

      initEventListeners() {
        this.pdfFile1.addEventListener("change", () =>
          this.validateMergeButton()
        );
        this.pdfFile2.addEventListener("change", () =>
          this.validateMergeButton()
        );
        this.mergePdfBtn.addEventListener("click", () => this.mergePDFs());
        this.downloadBtn.addEventListener("click", () =>
          this.downloadMergedPDF()
        );
      }

      validateMergeButton() {
        const hasFile1 = this.pdfFile1.files.length > 0;
        const hasFile2 = this.pdfFile2.files.length > 0;
        this.mergePdfBtn.disabled = !(hasFile1 && hasFile2);

        // Hide previous results when new files are selected
        if (hasFile1 || hasFile2) {
          this.pdfResult.style.display = "none";
        }
      }

      async mergePDFs() {
        try {
          this.showStatus("Reading PDF files...", 10);

          const file1 = this.pdfFile1.files[0];
          const file2 = this.pdfFile2.files[0];

          if (!file1 || !file2) {
            throw new Error("Please select both PDF files");
          }

          this.showStatus("Loading first PDF...", 25);
          const pdf1ArrayBuffer = await file1.arrayBuffer();
          const pdf1 = await PDFLib.PDFDocument.load(pdf1ArrayBuffer);

          this.showStatus("Loading second PDF...", 50);
          const pdf2ArrayBuffer = await file2.arrayBuffer();
          const pdf2 = await PDFLib.PDFDocument.load(pdf2ArrayBuffer);

          this.showStatus("Creating merged PDF...", 75);
          const mergedPdf = await PDFLib.PDFDocument.create();

          // Copy pages from first PDF
          const pdf1Pages = await mergedPdf.copyPages(
            pdf1,
            pdf1.getPageIndices()
          );
          pdf1Pages.forEach((page) => mergedPdf.addPage(page));

          // Copy pages from second PDF
          const pdf2Pages = await mergedPdf.copyPages(
            pdf2,
            pdf2.getPageIndices()
          );
          pdf2Pages.forEach((page) => mergedPdf.addPage(page));

          this.showStatus("Generating download...", 90);

          // Generate the merged PDF
          this.mergedPdfData = await mergedPdf.save();

          this.showStatus("Complete!", 100);

          // Show success result
          setTimeout(() => {
            this.pdfStatus.style.display = "none";
            this.pdfResult.style.display = "block";
          }, 500);
        } catch (error) {
          this.showError("Error merging PDFs: " + error.message);
        }
      }

      showStatus(message, progress) {
        const statusMessage = this.pdfStatus.querySelector(".status-message");
        const progressFill = this.pdfStatus.querySelector(".progress-fill");

        statusMessage.textContent = message;
        progressFill.style.width = progress + "%";
        this.pdfStatus.style.display = "block";
      }

      showError(message) {
        this.pdfStatus.style.display = "none";
        this.pdfResult.style.display = "none";

        const errorDiv = document.createElement("div");
        errorDiv.className = "error-message";
        errorDiv.textContent = message;
        errorDiv.style.margin = "20px 0";

        const mergeControls = document.querySelector(".merge-controls");
        mergeControls.appendChild(errorDiv);

        setTimeout(() => {
          errorDiv.remove();
        }, 5000);
      }

      downloadMergedPDF() {
        if (!this.mergedPdfData) {
          this.showError("No merged PDF available for download");
          return;
        }

        try {
          const blob = new Blob([this.mergedPdfData], {
            type: "application/pdf",
          });
          const url = URL.createObjectURL(blob);

          const a = document.createElement("a");
          a.href = url;
          a.download = "merged-document.pdf";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);

          URL.revokeObjectURL(url);
        } catch (error) {
          this.showError("Error downloading PDF: " + error.message);
        }
      }
    }

    // ZIP ‚Üí Merged PDF (client-only)
    class ZipPdfMerger {
      constructor() {
        this.zipInput = document.getElementById("zipInput");
        this.zipPdfList = document.getElementById("zipPdfList");
        this.mergeZipBtn = document.getElementById("mergeZipBtn");
        this.zipStatus = document.getElementById("zipStatus");
        this.zipResult = document.getElementById("zipResult");
        this.zipDownloadBtn = document.getElementById("zipDownloadBtn");

        this.pdfEntries = []; // [{path, getArrayBuffer}]
        this.mergedPdfData = null;

        this.initEvents();
      }

      initEvents() {
        this.zipInput.addEventListener("change", () => this.handleZip());
        this.mergeZipBtn.addEventListener("click", () => this.mergeFromZip());
        this.zipDownloadBtn.addEventListener("click", () =>
          this.downloadMergedPDF()
        );
      }

      async handleZip() {
        this.resetUI();
        const file = this.zipInput.files?.[0];
        if (!file) {
          this.renderList([], "No ZIP loaded yet");
          this.mergeZipBtn.disabled = true;
          return;
        }

        try {
          this.showStatus("Reading ZIP file...", 5);
          const zip = await JSZip.loadAsync(file);

          const pdfs = [];
          zip.forEach((relativePath, zipEntry) => {
            if (!zipEntry.dir && /\.pdf$/i.test(relativePath)) {
              pdfs.push({
                path: relativePath,
                getArrayBuffer: () => zipEntry.async("arraybuffer"),
              });
            }
          });

          pdfs.sort((a, b) =>
            a.path
              .toLowerCase()
              .localeCompare(b.path.toLowerCase(), undefined, {
                numeric: true,
              })
          );

          this.pdfEntries = pdfs;

          if (pdfs.length === 0) {
            this.renderList([], "No PDFs found in the ZIP");
            this.mergeZipBtn.disabled = true;
            this.showStatus("ZIP loaded (no PDFs).", 100);
            return;
          }

          this.renderList(pdfs, `Found ${pdfs.length} PDF file(s).`);
          this.mergeZipBtn.disabled = false;
          this.showStatus(`ZIP loaded. ${pdfs.length} PDF(s) ready.`, 100);
        } catch (err) {
          this.errorToast(`Failed to read ZIP: ${err.message || err}`);
          this.mergeZipBtn.disabled = true;
          this.renderList([], "Error reading ZIP");
          this.zipStatus.style.display = "none";
        }
      }

      renderList(items, headerText) {
        this.zipPdfList.innerHTML = "";
        const header = document.createElement("div");
        header.className = "list-header";
        header.textContent = headerText || `Found ${items.length} PDF(s)`;
        this.zipPdfList.appendChild(header);

        if (!items.length) return;

        items.forEach((it, idx) => {
          const row = document.createElement("div");
          row.className = "box-item";
          row.innerHTML = `
              <div class="box-info">
                <div class="box-coordinates">${idx + 1}. ${it.path}</div>
                <div class="box-label">Included</div>
              </div>
            `;
          this.zipPdfList.appendChild(row);
        });
      }

      async mergeFromZip() {
        if (!this.pdfEntries.length) {
          this.errorToast("No PDFs to merge. Load a ZIP first.");
          return;
        }

        try {
          this.zipResult.style.display = "none";
          this.showStatus("Creating merged PDF...", 10);

          const merged = await PDFLib.PDFDocument.create();

          const total = this.pdfEntries.length;
          for (let i = 0; i < total; i++) {
            const entry = this.pdfEntries[i];
            this.showStatus(
              `Loading PDF ${i + 1} of ${total}: ${entry.path}`,
              Math.min(15 + (i * 70) / total, 85)
            );

            const buf = await entry.getArrayBuffer();
            const doc = await PDFLib.PDFDocument.load(buf);
            const pages = await merged.copyPages(doc, doc.getPageIndices());
            pages.forEach((p) => merged.addPage(p));
          }

          this.showStatus("Finalizing merged PDF...", 90);
          this.mergedPdfData = await merged.save();

          this.showStatus("Complete!", 100);
          setTimeout(() => {
            this.zipStatus.style.display = "none";
            this.zipResult.style.display = "block";
          }, 400);
        } catch (err) {
          this.errorToast(
            `Error merging PDFs from ZIP: ${err.message || err}`
          );
          this.zipStatus.style.display = "none";
          this.zipResult.style.display = "none";
        }
      }

      downloadMergedPDF() {
        if (!this.mergedPdfData) {
          this.errorToast("No merged PDF available to download.");
          return;
        }
        const blob = new Blob([this.mergedPdfData], {
          type: "application/pdf",
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "zip-merged.pdf";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      showStatus(message, progress) {
        const statusMessage = this.zipStatus.querySelector(".status-message");
        const progressFill = this.zipStatus.querySelector(".progress-fill");
        statusMessage.textContent = message;
        progressFill.style.width = `${progress}%`;
        this.zipStatus.style.display = "block";
      }

      resetUI() {
        this.zipStatus.style.display = "none";
        this.zipResult.style.display = "none";
        this.mergedPdfData = null;
        this.pdfEntries = [];
      }

      errorToast(message) {
        const div = document.createElement("div");
        div.className = "error-message";
        div.textContent = message;
        div.style.margin = "20px 0";
        const controls = document.querySelector(
          "#zipMergerTool .merge-controls"
        );
        controls.appendChild(div);
        setTimeout(() => div.remove(), 5000);
      }
    }

    // Pixel Distance Measurement
    class MeasurementTool {
      constructor() {
        this.imageInput = document.getElementById("measureImageInput");
        this.resetBtn = document.getElementById("measureResetBtn");
        this.container = document.getElementById("measureContainer");
        this.image = document.getElementById("measureImage");
        this.canvas = document.getElementById("measureCanvas");
        this.info = document.getElementById("measureInfo");
        this.ctx = this.canvas.getContext("2d");
        this.points = [];
        this.scaleX = 1;
        this.scaleY = 1;

        this.initEvents();
      }

      initEvents() {
        this.imageInput.addEventListener("change", () => this.loadImage());
        this.resetBtn.addEventListener("click", () => this.reset());
        window.addEventListener("resize", () => this.syncCanvasSize());
        this.canvas.addEventListener("click", (e) => this.handleClick(e));
      }

      loadImage() {
        const file = this.imageInput.files[0];
        if (!file) {
          this.reset();
          return;
        }
        const reader = new FileReader();
        reader.onload = (e) => {
          this.image.src = e.target.result;
          this.image.onload = () => {
            this.container.style.display = "inline-block";
            this.points = [];
            this.updateInfo();
            this.syncCanvasSize();
            this.clearCanvas();
          };
        };
        reader.readAsDataURL(file);
      }

      syncCanvasSize() {
        if (!this.image.naturalWidth) return;
        const displayWidth = this.image.offsetWidth;
        const displayHeight = this.image.offsetHeight;
        this.canvas.width = displayWidth;
        this.canvas.height = displayHeight;
        this.scaleX = this.image.naturalWidth / displayWidth;
        this.scaleY = this.image.naturalHeight / displayHeight;
        this.redraw();
      }

      handleClick(event) {
        if (!this.image.src) return;
        const rect = this.canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        const point = {
          displayX: x,
          displayY: y,
          naturalX: x * this.scaleX,
          naturalY: y * this.scaleY,
        };
        this.points.push(point);
        if (this.points.length > 2) this.points.shift();
        this.redraw();
        this.updateInfo();
      }

      reset() {
        this.points = [];
        this.clearCanvas();
        this.info.style.display = "none";
      }

      clearCanvas() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      }

      redraw() {
        this.clearCanvas();
        if (this.points.length === 0) return;
        this.ctx.fillStyle = "#ff4757";
        this.ctx.strokeStyle = "#ff4757";
        this.ctx.lineWidth = 2;
        for (const p of this.points) {
          this.ctx.beginPath();
          this.ctx.arc(p.displayX, p.displayY, 5, 0, Math.PI * 2);
          this.ctx.fill();
        }
        if (this.points.length === 2) {
          const [p1, p2] = this.points;
          this.ctx.beginPath();
          this.ctx.moveTo(p1.displayX, p1.displayY);
          this.ctx.lineTo(p2.displayX, p2.displayY);
          this.ctx.stroke();
        }
      }

      updateInfo() {
        if (this.points.length < 2) {
          this.info.style.display = this.points.length ? "block" : "none";
          if (this.points.length === 1) {
            const p = this.points[0];
            this.info.innerHTML = `<strong>First point:</strong> (${Math.round(
              p.naturalX
            )}, ${Math.round(p.naturalY)})`;
          }
          return;
        }
        const [p1, p2] = this.points;
        const dx = p2.naturalX - p1.naturalX;
        const dy = p2.naturalY - p1.naturalY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        this.info.style.display = "block";
        this.info.innerHTML = `
            <div><strong>Point 1 (px):</strong> (${Math.round(
          p1.naturalX
        )}, ${Math.round(p1.naturalY)})</div>
            <div><strong>Point 2 (px):</strong> (${Math.round(
          p2.naturalX
        )}, ${Math.round(p2.naturalY)})</div>
            <div style="margin-top:8px;"><strong>Distance:</strong> ${distance.toFixed(
          2
        )} px</div>
          `;
      }
    }

    class PolygonBoundingBoxGenerator {
      constructor() {
        this.imageInput = document.getElementById("imageInput");
        this.polygonCoords = document.getElementById("polygonCoords");
        this.polygonLabel = document.getElementById("polygonLabel");
        this.polygonAngle = document.getElementById("polygonAngle");
        this.addPolygonBtn = document.getElementById("addPolygonBtn");
        this.bulkData = document.getElementById("bulkData");
        this.importBtn = document.getElementById("importBtn");
        this.generateBtn = document.getElementById("generateBtn");
        this.imageContainer = document.getElementById("imageContainer");
        this.uploadedImage = document.getElementById("uploadedImage");
        this.boundingBoxContainer = document.getElementById(
          "boundingBoxContainer"
        );
        this.boundingBoxList = document.getElementById("boundingBoxList");
        this.coordinatesDisplay =
          document.getElementById("coordinatesDisplay");
        this.coordinatesText = document.getElementById("coordinatesText");
        this.errorMessage = document.getElementById("errorMessage");

        this.polygons = [];
        this.colors = [
          "#ff4757",
          "#2ed573",
          "#3742fa",
          "#ffa502",
          "#ff6b81",
          "#70a1ff",
          "#5352ed",
          "#ff3838",
          "#ff9ff3",
          "#54a0ff",
          "#5f27cd",
          "#00d2d3",
          "#ff9f43",
          "#10ac84",
          "#ee5a24",
        ];

        this.initEventListeners();
      }

      initEventListeners() {
        this.imageInput.addEventListener("change", () =>
          this.handleImageUpload()
        );
        this.polygonCoords.addEventListener("input", () =>
          this.validateAddPolygon()
        );
        this.addPolygonBtn.addEventListener("click", () => this.addPolygon());
        this.importBtn.addEventListener("click", () => this.importBulkData());
        this.generateBtn.addEventListener("click", () =>
          this.generateVisualization()
        );

        this.polygonCoords.addEventListener("keydown", (e) => {
          if (e.ctrlKey && e.key === "Enter" && !this.addPolygonBtn.disabled) {
            this.addPolygon();
          }
        });

        this.polygonLabel.addEventListener("keypress", (e) => {
          if (e.key === "Enter" && !this.addPolygonBtn.disabled) {
            this.addPolygon();
          }
        });

        this.polygonAngle.addEventListener("keypress", (e) => {
          if (e.key === "Enter" && !this.addPolygonBtn.disabled) {
            this.addPolygon();
          }
        });

        this.bulkData.addEventListener("keydown", (e) => {
          if (e.ctrlKey && e.key === "Enter" && !this.importBtn.disabled) {
            this.importBulkData();
          }
        });
      }

      handleImageUpload() {
        const file = this.imageInput.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (e) => {
            this.uploadedImage.src = e.target.result;
            this.uploadedImage.onload = () => {
              this.clearAllPolygons();
              this.validateAddPolygon();
              this.updateGenerateButton();
            };
          };
          reader.readAsDataURL(file);
        } else {
          this.clearAllPolygons();
          this.validateAddPolygon();
          this.updateGenerateButton();
        }
      }

      validateAddPolygon() {
        const hasImage = this.imageInput.files.length > 0;
        const hasPolygonData = this.polygonCoords.value.trim() !== "";

        this.addPolygonBtn.disabled = !(hasImage && hasPolygonData);
        this.importBtn.disabled = !hasImage;
        this.hideError();
      }

      updateGenerateButton() {
        const hasImage = this.imageInput.files.length > 0;
        const hasPolygons = this.polygons.length > 0;

        this.generateBtn.disabled = !(hasImage && hasPolygons);
      }

      parsePolygonCoordinates(input) {
        try {
          const data = JSON.parse(input.trim());

          if (data.coords && Array.isArray(data.coords)) {
            const coords = data.coords;
            if (coords.length < 3) {
              throw new Error("Polygon must have at least 3 points");
            }
            for (let i = 0; i < coords.length; i++) {
              const point = coords[i];
              if (!point.hasOwnProperty("x") || !point.hasOwnProperty("y")) {
                throw new Error(
                  `Point ${i + 1} must have x and y properties`
                );
              }
              if (typeof point.x !== "number" || typeof point.y !== "number") {
                throw new Error(`Point ${i + 1} coordinates must be numbers`);
              }
              if (point.x < 0 || point.y < 0) {
                throw new Error(
                  `Point ${i + 1} coordinates cannot be negative`
                );
              }
            }
            return coords;
          } else if (Array.isArray(data)) {
            const coords = data;
            if (coords.length < 3) {
              throw new Error("Polygon must have at least 3 points");
            }
            for (let i = 0; i < coords.length; i++) {
              const point = coords[i];
              if (!point.hasOwnProperty("x") || !point.hasOwnProperty("y")) {
                throw new Error(
                  `Point ${i + 1} must have x and y properties`
                );
              }
              if (typeof point.x !== "number" || typeof point.y !== "number") {
                throw new Error(`Point ${i + 1} coordinates must be numbers`);
              }
              if (point.x < 0 || point.y < 0) {
                throw new Error(
                  `Point ${i + 1} coordinates cannot be negative`
                );
              }
            }
            return coords;
          } else {
            throw new Error(
              "Coordinates must be an array or an object with coords property"
            );
          }
        } catch (error) {
          if (error instanceof SyntaxError) {
            throw new Error(
              "Invalid JSON format. Please check your coordinate syntax."
            );
          }
          throw error;
        }
      }

      validatePolygonCoordinates(coords, imageWidth, imageHeight) {
        let clippingOccurred = false;
        const clippedCoords = coords.map((point) => {
          let clippedX = point.x;
          let clippedY = point.y;

          if (point.x < 0) {
            clippedX = 0;
            clippingOccurred = true;
          } else if (point.x > imageWidth) {
            clippedX = imageWidth;
            clippingOccurred = true;
          }

          if (point.y < 0) {
            clippedY = 0;
            clippingOccurred = true;
          } else if (point.y > imageHeight) {
            clippedY = imageHeight;
            clippingOccurred = true;
          }

          return { x: clippedX, y: clippedY };
        });

        if (clippingOccurred) {
          this.showWarning(
            "Some polygon coordinates were clipped to fit within image boundaries. The polygon has been adjusted to stay within the image bounds."
          );
        }

        return clippedCoords;
      }

      getNextColor() {
        return this.colors[this.polygons.length % this.colors.length];
      }

      calculateBoundingBox(coords) {
        let minX = coords[0].x;
        let minY = coords[0].y;
        let maxX = coords[0].x;
        let maxY = coords[0].y;

        for (let i = 1; i < coords.length; i++) {
          minX = Math.min(minX, coords[i].x);
          minY = Math.min(minY, coords[i].y);
          maxX = Math.max(maxX, coords[i].x);
          maxY = Math.max(maxY, coords[i].y);
        }

        return {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY,
        };
      }

      rotatePolygon(coords, angle) {
        if (!angle || angle === 0) {
          return coords;
        }
        const radians = (angle * Math.PI) / 180;
        const centerX =
          coords.reduce((sum, point) => sum + point.x, 0) / coords.length;
        const centerY =
          coords.reduce((sum, point) => sum + point.y, 0) / coords.length;

        return coords.map((point) => {
          const dx = point.x - centerX;
          const dy = point.y - centerY;
          const rotatedX = dx * Math.cos(radians) - dy * Math.sin(radians);
          const rotatedY = dx * Math.sin(radians) + dy * Math.cos(radians);
          return { x: rotatedX + centerX, y: rotatedY + centerY };
        });
      }

      addPolygon() {
        try {
          const polygonInput = this.polygonCoords.value;
          const coords = this.parsePolygonCoordinates(polygonInput);
          const label =
            this.polygonLabel.value.trim() ||
            `Polygon ${this.polygons.length + 1}`;

          let angle = parseFloat(this.polygonAngle.value) || 0;

          try {
            const data = JSON.parse(polygonInput.trim());
            if (data.angle !== undefined) {
              angle = parseFloat(data.angle) || 0;
            }
          } catch (e) { }

          if (angle < 0 || angle > 360) {
            throw new Error("Angle must be between 0 and 360 degrees");
          }

          const rotatedCoords = this.rotatePolygon(coords, angle);

          const naturalWidth = this.uploadedImage.naturalWidth;
          const naturalHeight = this.uploadedImage.naturalHeight;
          const clippedCoords = this.validatePolygonCoordinates(
            rotatedCoords,
            naturalWidth,
            naturalHeight
          );

          const boundingBox = this.calculateBoundingBox(clippedCoords);

          const polygon = {
            id: Date.now(),
            coords: clippedCoords,
            originalCoords: coords,
            boundingBox: boundingBox,
            label: label,
            angle: angle,
            color: this.getNextColor(),
          };

          this.polygons.push(polygon);

          this.updatePolygonList();
          this.clearInputs();
          this.updateGenerateButton();
          this.hideError();
        } catch (error) {
          this.showError(error.message);
        }
      }

      removePolygon(id) {
        this.polygons = this.polygons.filter((polygon) => polygon.id !== id);
        this.updatePolygonList();
        this.updateGenerateButton();

        if (this.polygons.length > 0) {
          this.generateVisualization();
        } else {
          this.imageContainer.style.display = "none";
          this.coordinatesDisplay.style.display = "none";
        }
      }

      updatePolygonList() {
        if (this.polygons.length === 0) {
          this.boundingBoxList.classList.remove("has-boxes");
          return;
        }

        this.boundingBoxList.classList.add("has-boxes");
        this.boundingBoxList.innerHTML = "";

        const headerContainer = document.createElement("div");
        headerContainer.style.cssText =
          "display: flex; justify-content: space-between; align-items: center; padding: 10px 15px; border-bottom: 1px solid #dee2e6; background: #f8f9fa;";
        headerContainer.innerHTML = `
            <div style="font-weight: 600; color: #495057; font-size: 0.9em;">Added Polygons: ${this.polygons.length}</div>
            <button class="clear-all-btn" onclick="app.clearAllPolygons()">Clear All</button>
          `;
        this.boundingBoxList.appendChild(headerContainer);

        this.polygons.forEach((polygon) => {
          const polygonItem = document.createElement("div");
          polygonItem.className = "box-item";
          const coordsText = polygon.coords
            .map((p) => `(${p.x},${p.y})`)
            .join(" ");
          const angleText = polygon.angle ? ` (${polygon.angle}¬∞)` : "";
          polygonItem.innerHTML = `
              <div style="display: flex; align-items: center;">
                <div class="box-color" style="background-color: ${polygon.color};"></div>
                <div class="box-info">
                  <div class="box-coordinates">${coordsText}</div>
                  <div class="box-label">${polygon.label} - ${polygon.coords.length} points${angleText}</div>
                </div>
              </div>
              <div class="box-actions">
                <button class="remove-box-btn" onclick="app.removePolygon(${polygon.id})">Remove</button>
              </div>
            `;
          this.boundingBoxList.appendChild(polygonItem);
        });
      }

      clearInputs() {
        this.polygonCoords.value = "";
        this.polygonLabel.value = "";
        this.polygonAngle.value = "";
        this.validateAddPolygon();
      }

      clearAllPolygons() {
        this.polygons = [];
        this.updatePolygonList();
        this.boundingBoxContainer.innerHTML = "";
      }

      parseBulkPolygonData(text) {
        const lines = text.split("\n").filter((line) => line.trim() !== "");
        const polygons = [];
        let lineNumber = 1;

        for (const line of lines) {
          try {
            const trimmedLine = line.trim();

            let coords,
              label,
              angle = 0;

            if (trimmedLine.includes(":")) {
              const colonIndex = trimmedLine.indexOf(":");
              label = trimmedLine.substring(0, colonIndex).trim();
              const dataText = trimmedLine.substring(colonIndex + 1).trim();

              try {
                const data = JSON.parse(dataText);
                if (data.coords) {
                  coords = data.coords;
                  angle = data.angle || 0;
                } else {
                  coords = data;
                }
              } catch {
                coords = JSON.parse(dataText);
              }
            } else {
              try {
                const data = JSON.parse(trimmedLine);
                if (data.coords) {
                  coords = data.coords;
                  angle = data.angle || 0;
                  label = data.label || `Polygon ${polygons.length + 1}`;
                } else {
                  coords = data;
                  label = `Polygon ${polygons.length + 1}`;
                }
              } catch {
                coords = JSON.parse(trimmedLine);
                label = `Polygon ${polygons.length + 1}`;
              }
            }

            if (!Array.isArray(coords)) {
              throw new Error("Coordinates must be an array");
            }

            if (coords.length < 3) {
              throw new Error("Polygon must have at least 3 points");
            }

            for (let i = 0; i < coords.length; i++) {
              const point = coords[i];
              if (!point.hasOwnProperty("x") || !point.hasOwnProperty("y")) {
                throw new Error(
                  `Point ${i + 1} must have x and y properties`
                );
              }

              if (
                typeof point.x !== "number" ||
                typeof point.y !== "number"
              ) {
                throw new Error(`Point ${i + 1} coordinates must be numbers`);
              }
            }

            polygons.push({
              coords: coords,
              label: label,
              angle: angle,
            });
          } catch (error) {
            throw new Error(`Line ${lineNumber}: ${error.message}`);
          }

          lineNumber++;
        }

        return polygons;
      }

      importBulkData() {
        try {
          const bulkText = this.bulkData.value.trim();
          if (!bulkText) {
            this.showError("Please paste some polygon data to import");
            return;
          }

          const parsedPolygons = this.parseBulkPolygonData(bulkText);
          if (parsedPolygons.length === 0) {
            this.showError(
              "No valid polygons found in the data. Please check the format."
            );
            return;
          }

          const naturalWidth = this.uploadedImage.naturalWidth;
          const naturalHeight = this.uploadedImage.naturalHeight;

          for (let polygon of parsedPolygons) {
            polygon.originalCoords = [...polygon.coords];
            const rotatedCoords = this.rotatePolygon(
              polygon.coords,
              polygon.angle || 0
            );
            const clippedCoords = this.validatePolygonCoordinates(
              rotatedCoords,
              naturalWidth,
              naturalHeight
            );
            polygon.coords = clippedCoords;
          }

          this.polygons = [];

          parsedPolygons.forEach((polygon, index) => {
            const boundingBox = this.calculateBoundingBox(polygon.coords);
            const polygonObj = {
              id: Date.now() + index,
              coords: polygon.coords,
              originalCoords: polygon.originalCoords || polygon.coords,
              boundingBox: boundingBox,
              label: polygon.label,
              angle: polygon.angle || 0,
              color: this.colors[index % this.colors.length],
            };
            this.polygons.push(polygonObj);
          });

          this.updatePolygonList();
          this.updateGenerateButton();
          this.hideError();

          this.showSuccess(
            `Successfully imported ${parsedPolygons.length} polygons!`
          );
        } catch (error) {
          this.showError(error.message);
        }
      }

      showSuccess(message) {
        this.errorMessage.textContent = message;
        this.errorMessage.style.background = "#d4edda";
        this.errorMessage.style.color = "#155724";
        this.errorMessage.style.borderLeftColor = "#28a745";
        this.errorMessage.style.display = "block";

        setTimeout(() => {
          this.errorMessage.style.background = "#ffe6e6";
          this.errorMessage.style.color = "#d63031";
          this.errorMessage.style.borderLeftColor = "#d63031";
        }, 3000);
      }

      generateVisualization() {
        try {
          if (this.polygons.length === 0) {
            this.showError("Please add at least one polygon");
            return;
          }

          this.boundingBoxContainer.innerHTML = "";

          const naturalWidth = this.uploadedImage.naturalWidth;
          const naturalHeight = this.uploadedImage.naturalHeight;
          const displayWidth = this.uploadedImage.offsetWidth;
          const displayHeight = this.uploadedImage.offsetHeight;

          const scaleX = displayWidth / naturalWidth;
          const scaleY = displayHeight / naturalHeight;

          this.polygons.forEach((polygon) => {
            const { coords, color, label, boundingBox } = polygon;

            const svg = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "svg"
            );
            svg.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
              `;

            const polygonElement = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "polygon"
            );

            const scaledPoints = coords
              .map((point) => `${point.x * scaleX},${point.y * scaleY}`)
              .join(" ");

            polygonElement.setAttribute("points", scaledPoints);
            polygonElement.style.cssText = `
                fill: ${color}20;
                stroke: ${color};
                stroke-width: 2;
                stroke-dasharray: none;
              `;

            svg.appendChild(polygonElement);

            const boundingRect = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "rect"
            );
            const scaledBBox = {
              x: boundingBox.x * scaleX,
              y: boundingBox.y * scaleY,
              width: boundingBox.width * scaleX,
              height: boundingBox.height * scaleY,
            };

            boundingRect.setAttribute("x", scaledBBox.x);
            boundingRect.setAttribute("y", scaledBBox.y);
            boundingRect.setAttribute("width", scaledBBox.width);
            boundingRect.setAttribute("height", scaledBBox.height);
            boundingRect.style.cssText = `
                fill: none;
                stroke: ${color};
                stroke-width: 2;
                stroke-dasharray: 5,5;
              `;

            svg.appendChild(boundingRect);

            if (scaledBBox.width > 60 && scaledBBox.height > 25) {
              const labelElement = document.createElement("div");
              labelElement.style.cssText = `
                  position: absolute;
                  top: ${scaledBBox.y - 25}px;
                  left: ${scaledBBox.x}px;
                  background: ${color};
                  color: white;
                  padding: 4px 8px;
                  border-radius: 4px;
                  font-size: 12px;
                  font-weight: 600;
                  white-space: nowrap;
                  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                  pointer-events: none;
                `;
              labelElement.textContent = label;
              this.boundingBoxContainer.appendChild(labelElement);
            }

            this.boundingBoxContainer.appendChild(svg);
          });

          this.imageContainer.style.display = "inline-block";
          this.coordinatesDisplay.style.display = "block";

          const totalArea = this.polygons.reduce((sum, polygon) => {
            return (
              sum + polygon.boundingBox.width * polygon.boundingBox.height
            );
          }, 0);

          this.coordinatesText.innerHTML = `
              <div><strong>Total Polygons:</strong> ${this.polygons.length
            }</div>
              <div><strong>Image Dimensions:</strong> ${naturalWidth} √ó ${naturalHeight} pixels</div>
              <div><strong>Total Bounding Box Area:</strong> ${totalArea.toLocaleString()} pixels¬≤</div>
              <div style="margin-top: 10px;"><strong>Polygon Details:</strong></div>
              ${this.polygons
              .map((polygon) => {
                const pointsText = polygon.coords
                  .map((p) => `(${p.x},${p.y})`)
                  .join(", ");
                const area =
                  polygon.boundingBox.width * polygon.boundingBox.height;
                const angleText = polygon.angle
                  ? ` | Angle: ${polygon.angle}¬∞`
                  : "";
                return `<div style="margin: 5px 0; padding: 8px; background: #f8f9fa; border-radius: 4px; border-left: 4px solid ${polygon.color
                  };">
                    <span style="font-weight: 600;">${polygon.label}:</span><br>
                    <span style="font-size: 0.9em; color: #6c757d;">Points: ${pointsText}</span><br>
                    <span style="font-size: 0.9em; color: #6c757d;">Bounding Box: (${polygon.boundingBox.x
                  }, ${polygon.boundingBox.y}, ${polygon.boundingBox.width
                  }, ${polygon.boundingBox.height})</span><br>
                    <span style="color: #6c757d;">Area: ${area.toLocaleString()} px¬≤${angleText}</span>
                  </div>`;
              })
              .join("")}
            `;

          this.hideError();
        } catch (error) {
          this.showError(error.message);
        }
      }

      showError(message) {
        this.errorMessage.textContent = message;
        this.errorMessage.style.display = "block";
      }

      showWarning(message) {
        this.errorMessage.textContent = message;
        this.errorMessage.style.background = "#fff3cd";
        this.errorMessage.style.color = "#856404";
        this.errorMessage.style.borderLeftColor = "#ffc107";
        this.errorMessage.style.display = "block";

        setTimeout(() => {
          this.errorMessage.style.background = "#ffe6e6";
          this.errorMessage.style.color = "#d63031";
          this.errorMessage.style.borderLeftColor = "#d63031";
        }, 5000);
      }

      hideError() {
        this.errorMessage.style.display = "none";
      }
    }

    // PDF to Pages Class
    class PDFToPages {
      constructor() {
        this.input = document.getElementById("pdfToPagesInput");
        this.results = document.getElementById("pdfPagesResults");
        this.status = document.getElementById("pdfToPagesStatus");
        this.downloadAllBtn = document.getElementById("downloadAllPagesBtn");
        this.pdf = null;
        this.totalPages = 0;

        this.initEvents();
      }

      initEvents() {
        this.input.addEventListener("change", () => this.handleFile());
        this.downloadAllBtn.addEventListener("click", () => this.downloadAll());
      }

      async handleFile() {
        const file = this.input.files[0];
        if (!file) return;

        this.results.innerHTML = "";
        this.downloadAllBtn.disabled = true;
        this.showStatus("Loading PDF...", 5);

        try {
          const arrayBuffer = await file.arrayBuffer();
          const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
          this.pdf = await loadingTask.promise;
          this.totalPages = this.pdf.numPages;

          this.showStatus(`Processing ${this.totalPages} pages...`, 10);

          const BATCH_SIZE = 20;
          for (let batch = 0; batch < Math.ceil(this.totalPages / BATCH_SIZE); batch++) {
            const start = batch * BATCH_SIZE + 1;
            const end = Math.min((batch + 1) * BATCH_SIZE, this.totalPages);

            for (let i = start; i <= end; i++) {
              this.showStatus(`Rendering page ${i}/${this.totalPages}...`, 10 + (i / this.totalPages) * 80);

              const page = await this.pdf.getPage(i);
              const thumbViewport = page.getViewport({ scale: 0.5 });
              const canvas = document.createElement("canvas");
              const context = canvas.getContext("2d");
              canvas.height = thumbViewport.height;
              canvas.width = thumbViewport.width;

              await page.render({ canvasContext: context, viewport: thumbViewport }).promise;
              const thumbUrl = canvas.toDataURL("image/jpeg", 0.7);
              this.renderPreview(i, thumbUrl);

              page.cleanup();
              canvas.width = 0;
              canvas.height = 0;
            }
            await new Promise(resolve => setTimeout(resolve, 50));
          }

          this.showStatus("Complete! Click 'Download All' for HD images.", 100);
          this.downloadAllBtn.disabled = false;
          setTimeout(() => (this.status.style.display = "none"), 3000);
        } catch (err) {
          this.showStatus(`Error: ${err.message}`, 0);
          console.error(err);
        }
      }

      renderPreview(index, dataUrl) {
        const card = document.createElement("div");
        card.style.cssText = "background: white; border-radius: 8px; padding: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);";
        card.innerHTML = `
          <div style="font-weight: 600; margin-bottom: 8px;">Page ${index}</div>
          <img src="${dataUrl}" style="width: 100%; border-radius: 4px;" loading="lazy" />
          <button onclick="pdfToPages.downloadSingle(${index})" style="width: 100%; margin-top: 8px; padding: 8px; background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: white; border: none; border-radius: 4px; cursor: pointer;">
            üíæ Download HD
          </button>
        `;
        this.results.appendChild(card);
      }

      async downloadSingle(pageNum) {
        if (!this.pdf) return;
        this.showStatus(`Rendering page ${pageNum} in HD...`, 50);
        try {
          const page = await this.pdf.getPage(pageNum);
          const viewport = page.getViewport({ scale: 2.0 });
          const canvas = document.createElement("canvas");
          const context = canvas.getContext("2d");
          canvas.height = viewport.height;
          canvas.width = viewport.width;
          await page.render({ canvasContext: context, viewport }).promise;
          const dataUrl = canvas.toDataURL("image/jpeg", 0.92);
          const a = document.createElement("a");
          a.href = dataUrl;
          a.download = `page-${pageNum}.jpg`;
          a.click();
          page.cleanup();
          canvas.width = 0;
          canvas.height = 0;
          this.showStatus("Download started!", 100);
          setTimeout(() => (this.status.style.display = "none"), 1500);
        } catch (err) {
          this.showStatus(`Error: ${err.message}`, 0);
        }
      }

      async downloadAll() {
        if (!this.pdf || this.totalPages === 0) return;
        this.downloadAllBtn.disabled = true;
        const zip = new JSZip();
        const imgFolder = zip.folder("pdf-pages");

        const scale = this.totalPages > 100 ? 0.75 : 1.2;
        const quality = this.totalPages > 100 ? 0.7 : 0.85;

        try {
          for (let i = 1; i <= this.totalPages; i++) {
            this.showStatus(`Exporting page ${i}/${this.totalPages}...`, (i / this.totalPages) * 90);
            const page = await this.pdf.getPage(i);
            const viewport = page.getViewport({ scale });
            const canvas = document.createElement("canvas");
            const context = canvas.getContext("2d");
            canvas.height = viewport.height;
            canvas.width = viewport.width;
            await page.render({ canvasContext: context, viewport }).promise;
            const blob = await new Promise(resolve => canvas.toBlob(resolve, "image/jpeg", quality));
            imgFolder.file(`page-${String(i).padStart(4, '0')}.jpg`, blob);
            page.cleanup();
            canvas.width = 0;
            canvas.height = 0;
            if (i % 5 === 0) await new Promise(resolve => setTimeout(resolve, 100));
          }
          this.showStatus("Creating ZIP (this may take a moment)...", 95);
          const content = await zip.generateAsync({ type: "blob", compression: "STORE" });
          const url = URL.createObjectURL(content);
          const a = document.createElement("a");
          a.href = url;
          a.download = "pdf-pages.zip";
          a.click();
          URL.revokeObjectURL(url);
          this.showStatus("Download started!", 100);
          setTimeout(() => (this.status.style.display = "none"), 2000);
        } catch (err) {
          this.showStatus(`Error: ${err.message}`, 0);
          console.error(err);
        } finally {
          this.downloadAllBtn.disabled = false;
        }
      }

      showStatus(message, progress) {
        const statusMessage = this.status.querySelector(".status-message");
        const progressFill = this.status.querySelector(".progress-fill");
        statusMessage.textContent = message;
        progressFill.style.width = `${progress}%`;
        this.status.style.display = "block";
      }
    }

    // Initialize the application when the page loads
    let app, pdfMerger, measurementTool, zipPdfMerger, pdfToPages;
    document.addEventListener("DOMContentLoaded", () => {
      app = new PolygonBoundingBoxGenerator();
      pdfMerger = new PDFMerger();
      measurementTool = new MeasurementTool();
      zipPdfMerger = new ZipPdfMerger();
      pdfToPages = new PDFToPages();
    });
  </script>
</body>

</html>